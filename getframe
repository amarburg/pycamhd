#!/usr/bin/env python
# This script remotely parses CamHD files in the raw data archive. Eventually
# it will be able to download a single frame or range of frames from a file in
# the archive without downloading the entire video file. This script is under
# heavy development and will change early and often in the coming days.
#
# Timothy Crone (tjcrone@gmail.com)

# imports
import sys, os, time, argparse, subprocess, struct

# parse command line argument
filename = sys.argv[1]

# get arbitrary bytes from remote mov file
def get_bytes(filename, byte_range):
  cmd = ('curl --header "Range: bytes=%i-%i" -k -s ' % 
    (byte_range[0], byte_range[1])) + filename
  p = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=True)
  file_bytes = p.communicate()[0]
  return file_bytes

# get integer from remote mov file bytes
def get_size(filename, byte_range):
  file_bytes = get_bytes(filename, byte_range)
  if len(file_bytes) == 4:
    return struct.unpack('>I', file_bytes)[0]
  elif len(file_bytes) ==8:
    return struct.unpack('>Q', file_bytes)[0]

# file to test
#filename = 'https://rawdata.oceanobservatories.org/files/RS03ASHS/PN03B/06-CAMHDA301/2016/11/13/CAMHDA301-20161113T000000Z.mov'

# get the ftyp atom size
byte_range = [0, 3]
ftyp_size = get_size(filename, byte_range)

# get the mdat atom size
byte_range = [ftyp_size, ftyp_size + 3]
mdat_size = get_size(filename, byte_range)
if mdat_size == 1:
  byte_range = [ftyp_size + 8, ftyp_size + 15]
  mdat_size = get_size(filename, byte_range)

# get the moov atom size
byte_range = [ftyp_size + mdat_size, ftyp_size + mdat_size + 3]
moov_size = get_size(filename, byte_range)

# download the moov atom
byte_range = [ftyp_size + mdat_size, ftyp_size + mdat_size + moov_size]
moov_atom = get_bytes(filename, byte_range)
#sys.stdout.write(moov_atom)

# parse the moov atam

#print struct.unpack('>I', moov_atom[0:4])[0]

#print struct.unpack('>I', moov_atom[8:12])[0]

print(str(ftyp_size) + ' ' + str(mdat_size) + ' ' + str(moov_atom.find('stsz')))

quit()

# for now assume that we have a frame position and size obtained from the moov atom
frame_position = [6094104432]
frame_size = [596992]

# download the frame data
byte_range = [frame_position[0], frame_position[0]+frame_size[0]-1]
frame_data = get_frame_data(filename, byte_range)

# attach an avi header
# this header is a total kluge. it should be rewritten based on the avi spec.
def binzeros(number):
  zeros = []
  for i in range(0, number):
    zeros.append(b'\x00')
  return zeros
avi_header = ''.join([b'\x52\x49\x46\x46\xaa\x32\x09\x00\x41\x56\x49\x20\x4c\x49\x53\x54',
  b'\x38\x12\x00\x00\x68\x64\x72\x6c\x61\x76\x69\x68\x38\x00\x00\x00',
  b'\x2b\x41\x00\x00\xc3\x3d\x09\x01\x00\x00\x00\x00\x10\x09\x00\x00',
  b'\x02\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x10\x00',
  b'\x80\x07\x00\x00\x38\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00',
  b'\x00\x00\x00\x00\x00\x00\x00\x00\x4c\x49\x53\x54\xe0\x10\x00\x00',
  b'\x73\x74\x72\x6c\x73\x74\x72\x68\x38\x00\x00\x00\x76\x69\x64\x73',
  b'\x61\x70\x63\x6e\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00',
  b'\xe9\x03\x00\x00\x60\xea\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00',
  b'\x00\x1c\x09\x00\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00',
  b'\x80\x07\x38\x04\x73\x74\x72\x66\x28\x00\x00\x00\x28\x00\x00\x00',
  b'\x80\x07\x00\x00\x38\x04\x00\x00\x01\x00\x18\x00\x61\x70\x63\x6e',
  b'\x00\xec\x5e\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00',
  b'\x00\x00\x00\x00\x4a\x55\x4e\x4b\x18\x10\x00\x00\x04\x00\x00\x00',
  b'\x00\x00\x00\x00\x30\x30\x64\x63\x00\x00\x00\x00\x00\x00\x00\x00'] + \
  binzeros(4096) + \
  [b'\x00\x00\x00\x00\x76\x70\x72\x70\x44\x00\x00\x00\x00\x00\x00\x00',
  b'\x00\x00\x00\x00\x3c\x00\x00\x00\x80\x07\x00\x00\x38\x04\x00\x00',
  b'\x09\x00\x10\x00\x80\x07\x00\x00\x38\x04\x00\x00\x01\x00\x00\x00',
  b'\x38\x04\x00\x00\x80\x07\x00\x00\x38\x04\x00\x00\x80\x07\x00\x00',
  b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00',
  b'\x4a\x55\x4e\x4b\x04\x01\x00\x00\x6f\x64\x6d\x6c\x64\x6d\x6c\x68\xf8'] + \
  binzeros(239) + \
  [b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x4c\x49\x53\x54',
  b'\x1a\x00\x00\x00\x49\x4e\x46\x4f\x49\x53\x46\x54\x0e\x00\x00\x00',
  b'\x4c\x61\x76\x66\x35\x37\x2e\x31\x39\x2e\x31\x30\x30\x00\x4a\x55',
  b'\x4e\x4b\xf8\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'] + \
  binzeros(1006) + \
  [b'\x4c\x49\x53\x54\x14\x1c\x09\x00\x6d\x6f\x76\x69\x30\x30\x64\x63\x00\x1c\x09\x00'])
avi_file = avi_header + frame_data
#sys.stdout.write(avi_file)

# write this avi to a temporary file
f = open('tmpavifile.avi', 'w')
f.write(avi_file)
f.close()

# convert to yuv rawvideo 
#  cmd = ('curl --header "Range: bytes=%i-%i" -k -s ' % 
#    (byte_range[0], byte_range[1])) + filename
#  p = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=True)
